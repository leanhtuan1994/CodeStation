s:25489:"<p></p><h3><strong>Your Situation</strong></h3><p>This could be quite varied, you could be:</p><ol><li>A solo developer looking for a fast/easy way to have a local dev environment that resembles your production environment (say you develop on OS X, but are deploying to an infrastructure running some distribution of Linux. As a bonus, there is also an easy way to deploy to Amazon’s EC2 if you have a solid setup locally.</li><li>A member of a team, where everyone has their own development style and want to avoid the headaches of cross-platform support.</li><li>Someone who normally sets up servers in a third-party hosting environment, but you want to test your deployment without paying a bunch of money in wasted servers (this is where I am!)</li></ol><h3><strong>What is Vagrant?</strong></h3><p><a href="http://vagrantup.com/" target="_blank" rel="noreferrer">Vagrant</a> is essentially a wrapper around a variety of virtual machine providers. If you have ever used Make to build a piece of software, it is kind of like that except with virtual machines. It provides a single command that uniformly creates, provisions, destroys, and connects to machines. You can use many different VM providers, but I will be using VirtualBox because it is free and easy to use. Usually it is a pain in the butt to create a virtual machine, install the operating system, etc. Vagrant makes it super easy, and there are lots of premade “boxes” for you to use (more on this later).</p><h3><strong>What is Puppet?</strong></h3><p><a href="http://puppetlabs.com/" target="_blank" rel="noreferrer">Puppet</a> is an infrastructure automation tool and we are going to use it to take the hard work out of setting up our systems. We can do this because lots of people have put a ton of effort into writing modules that we can use. This won’t be a tutorial on Puppet, but it will go over the basics so that you can use modules that other people have written.</p><h4><strong>But I don’t like/use Puppet!</strong></h4><p>That is fine. Thankfully Vagrant is flexible in its provisioners and you can read more about <a href="http://docs.vagrantup.com/v2/provisioning/index.html" target="_blank" rel="noreferrer">the alternatives</a>. For simplicity I am just going to cover Bash and Puppet since that is what I am familiar with. The overall process should be the same if you decide to use <a href="http://www.opscode.com/chef/" target="_blank" rel="noreferrer">Chef</a> or <a href="http://www.ansibleworks.com/" target="_blank" rel="noreferrer">Ansible</a>, but because I don’t know much about them, I won’t discuss them further.</p><h3><strong>Getting Started</strong></h3><h4><strong>Installation</strong></h4><p>Vagrant is a breeze to install: you can read over their <a href="http://docs.vagrantup.com/v2/installation/index.html" target="_blank" rel="noreferrer">installation instructions</a>. Essentially, download the package that is relevant for your platform of choice and install it in the way you would normally install a package.</p><p>You will also need to install your virtual machine provider, in my case <a href="https://www.virtualbox.org/" target="_blank" rel="noreferrer">VirtualBox</a>.</p><h4><strong>First VM</strong></h4><p>Once it is installed, you will want to create a new project directory and initialize it.</p><pre>$ mkdir ~/Vagrant<br />$ cd ~/Vagrant<br />$ vagrant init</pre><p>This will create a new directory and get it ready with a file called <a href="http://docs.vagrantup.com/v2/vagrantfile/index.html" target="_blank" rel="noreferrer">Vagrantfile</a>which will contain all the information that Vagrant needs to manage your dev environments.</p><p>In that file there will be a bunch of comments about the different things you can put in that file. For now we just care about configuring a base <a href="http://docs.vagrantup.com/v2/boxes.html" target="_blank" rel="noreferrer">“box”</a>(which is just a virtual machine image) and some other machine properties. I ended up with a file that looked something like this:</p><pre># -*- mode: ruby -*-<br /># vi: set ft=ruby :</pre><pre>Vagrant.configure(“2") do |config|<br /> # Every vagrant virtual env requires a box to build off of<br /> config.vm.box = “puppetlabs-precise64"<br /> config.vm.box_url = “http://puppet-vagrant-boxes.puppetlabs.com/ubuntu-server-12042-x64-vbox4210-nocm.box"<br /> config.vm.hostname = “development.kloudless.vm”<br /> config.vm.network :private_network, ip: “192.168.33.10"<br /> config.vm.network :forwarded_port, guest: 80, host: 8080</pre><pre> # VirtualBox Specific Customization<br /> config.vm.provider :virtualbox do |vb|<br /> # Use VBoxManage to customize the VM. For example to change memory:<br /> vb.customize [“modifyvm”, :id, “—memory”, “1024"]<br /> end<br />end</pre><p>Here are the things that we configured so far:</p><ol><li>config.vm.box: The name of the box that you are bringing up.</li><li>config.vm.box_url: The location where Vagrant can look to download the box if you don’t already have a copy on your machine.The box that I chose is provided by Puppet Labs and doesn’t have any pre-installed provisioning software. This will be installed later as part of the bootstrapping process so that it can always be up to date.</li><li>config.vm.hostname: The hostname of the VM.</li><li>config.vm.network :private_network: The private IP address that the VM will have on the private VM network.</li><li>config.vm.network :forwarded_port: The port labelled “guest” on the guest VM will be accessible on the port labelled “host” on your machine.</li><li>VM memory: I gave my VM 1GB because it seemed like it would be enough (<strong>Note</strong>: this is provider dependent).</li></ol><p>Once you have the file in place you can create and provision your VM from the same directory:</p><pre>$ vagrant up </pre><p>After that command finishes running, you will have a VM ready for you to connect and start messing around with. You can access the machine via SSH using:</p><pre>$ vagrant ssh </pre><p>You will now have a shell on your virtual machine as the vagrant user. The user has passwordless sudo access on the machine, it full fledged Ubuntu 12.04 LTS VM and you can do whatever you want! This is great and all, but we want to make things more automated, so you will want to exit your SSH session and get rid of the VM with:</p><pre>$ vagrant destroy </pre><h3><strong>Automating All the Things</strong></h3><p>As was talked about earlier, the nice thing about Vagrant is that it is really easy to offload the configuration to an automated tool, in this case Puppet. Since our VM is pretty bare bones, there is some extra work that we want to do to prepare it.</p><h4><strong>Bootstrapping</strong></h4><p>The box that I chose doesn’t by default come with puppet installed on it, this was a deliberate choice to make sure that I could use the same version I am using in production without having to change the box all the time. As such we need to do a little extra work. Preparing the machine to be puppeted is relatively straightforward and we are going to take advantage of the fact that you can use multiple provisioners on a single machine. In order to use the shell provisioner we add the following lines to our Vagrantfile before the final end:</p><pre># Enable shell provisioning to bootstrap puppet<br />config.vm.provision :shell, :path =&gt; “bootstrap.sh”</pre><p>Then we create a file called bootstrap.sh in the same folder as our Vagrantfile that contains the following:</p><pre>#!/usr/bin/env bash<br />set -e</pre><pre>if [ “$EUID” -ne “0" ] ; then<br /> echo “Script must be run as root.” &gt;&amp;2<br /> exit 1<br />fi</pre><pre>if which puppet &gt; /dev/null ; then<br /> echo “Puppet is already installed”<br /> exit 0<br />fi</pre><pre>echo “Installing Puppet repo for Ubuntu 12.04 LTS”<br />wget -qO /tmp/puppetlabs-release-precise.deb \<br /><a href="https://apt.puppetlabs.com/puppetlabs-release-precise.deb" target="_blank" rel="noreferrer">https://apt.puppetlabs.com/puppetlabs-release-precise.deb</a><br />dpkg -i /tmp/puppetlabs-release-precise.deb<br />rm /tmp/puppetlabs-release-precise.deb<br />aptitude update<br />#aptitude upgrade -y<br />echo Installing puppet<br />aptitude install -y puppet<br />echo “Puppet installed!”</pre><p>One important thing to notice is that the script is idempotent (meaning that it can be run multiple times without having any bad effects), this is important because we can run the provisioners without creating a new machine. Your virtual machine will now be ready to be controlled via Puppet!</p><h3><strong>Adding Puppet</strong></h3><p>Since we don’t want to install Puppet on our host machine, bring up the VM and connect to it. Puppet is already installed. We can do all of our initial Puppet configuration directly within the vm. By default, the folder containing the Vagrantfile is shared on the virtual machine in the path /vagrant and this will make a good location to store our puppet configurations. Once in that directory you will want to create a skeleton of your puppet dir:</p><pre>$ mkdir -p puppet/{manifests,modules}<br />$ touch manifests/site.pp </pre><p>From here we will want to install some puppet modules that will make setting up a basic LAMP server easy (for now we will just keep everything on the same box). There are lots of different ways to install puppet modules, but the most straightforward is using the way that is built into puppet:</p><pre>$ puppet module puppetlabs-apache —modulepath \<br />/vagrant/puppet/modules</pre><pre>$ puppet module install puppetlabs-mysql —modulepath \<br />/vagrant/puppet/modules</pre><p>Now we will want to actually write a puppet manifest , so we will want to create /vagrant/puppet/manifests/site.pp with the following:</p><pre>node ‘development.kloudless.vm’ { # [1]<br /> class { ‘mysql::server’: # [2]<br /> config_hash =&gt; { ‘root_password’ =&gt; ‘herpderpderp’ },<br /> }<br /> include mysql::php # [3]</pre><pre> # Configuring apache<br /> include apache # [4]<br /> include apache::mod::php</pre><pre> apache::vhost { $::fqdn: # [5]<br /> port =&gt; ‘80',<br /> docroot =&gt; ‘/var/www/test’,<br /> require =&gt; File[‘/var/www/test’],<br /> }</pre><pre> # Setting up the document root<br /> file { [‘/var/www’, ‘/var/www/test’] : # [6]<br /> ensure =&gt; directory,<br /> }</pre><pre> file { ‘/var/www/test/index.php’ : # [7]<br /> content =&gt; ‘&gt;?php echo \’&gt;p&lt;Hello world!&gt;/p&lt;\’ ?&lt;’,<br /> }</pre><pre> # “Realize” the firewall rule<br /> Firewall &lt;| |&gt; # [8]<br />}</pre><p>This describes how the server gets configured, the basic function is setting your vm with apache, mysql, and php along with a test page. Here are some more details about the different parts:</p><ol><li>The node definition is how we collect configuration for the machine, the label ‘development.kloudless.vm’ matches the hostname that we configured the vagrant box with.</li><li>This statement uses the mysql class to install the mysql server and sets up the admin password for the db as ‘herpderpderp’.</li><li>That is how the php bindings for mysql get installed</li><li>Those two lines install the apache server package and mod_php respectively</li><li>We want an apache vhost where we can access our basic test application.</li><li>This actually creates the directories where the vhost content will live</li><li>That is our application! Right now it doesn’t actually use the database, but it is a good example, we can define the contents of the file inline relatively easily this way. We will replace this later.</li><li>This is a way of realizing virtual resources which in this case configures your machine’s firewall rules.</li></ol><p>Now that we have the puppet configuration ready, we need to have Vagrant use it. This can be done easily by adding the following lines to your Vagrantfile after the shell provisioner lines:</p><pre># Enable provisioning with Puppet stand alone.<br />config.vm.provision :puppet do |puppet|<br /> puppet.manifests_path = “puppet/manifests”<br /> puppet.manifest_file = “site.pp”<br /> puppet.module_path = “puppet/modules”<br /> puppet.options = “—verbose —debug”<br />end </pre><p>This just tells vagrant where to find the modules we installed and the manifest we wrote. So now you are ready to vagrant up. Once your box is built, you should be able to visit <a href="http://localhost:8080/" target="_blank" rel="noreferrer">http://localhost:8080</a> and see the output of your test page.</p><p>With a few small adjustments, you could use this to develop a full blown php app. The adjustments you would probably want to make are as follows:</p><ol><li>Remove the index.php file block from the sites.pp file</li><li>Change the webroot value in the vhost code block to be “/var/www/app”</li><li>Configure a shared folder that apache can point to as the webroot. For example, if you have a folder called app that contained your application and it is in the same directory as your Vagrantfile, you would add the following line to the Vagrantfile:<br />config.vm.synced_folder “app”, “/var/www/app”</li></ol><p>Once those changes are made, you should be able to just run vagrant provision to update the settings and you can start dumping your project files into the app directory and you should see those changes on the vm.</p><h4><strong>Learning More</strong></h4><p>If you wanted a LAMP server to develop a php application, you don’t really need to go any further. Odds are, however, that you want to do something more than just this. If you want to run a more complicated application you can do this pretty easily if you can find a module to do it. The specific details of how you use a module depends on what it is, but the documentation is usually ok. If you want to more seriously manage your dev box with puppet, you should do some more reading so you can use the different modules people have written more easily. Here is some recommended reading :</p><ol><li><a href="http://docs.puppetlabs.com/learning/index.html" target="_blank" rel="noreferrer">The Learning Puppet Series</a></li><li><a href="http://www.example42.com/?q=Example42PuppetTutorials" target="_blank" rel="noreferrer">Example42 Tutorials</a>. They also have a bunch of good modules you can use</li><li><a href="http://docs.puppetlabs.com/puppet/3/reference/" target="_blank" rel="noreferrer">Puppet 3 reference manual</a></li></ol><h4><strong>Hiera</strong></h4><p>If you are a more experienced puppet user, you might be familiar with Hiera and want to use it with the modules/classes that you have written. It is pretty easy to do. First, change the value of puppet.options in your Vagrantfile to “—verbose —debug —hiera_config /vagrant/puppet/hiera.yaml”. Now you need to populate that file with your hiera configuration, depending on how you are using it you might end up with something like this:</p><pre>—-<br />:hierarchy:<br /> — common</pre><pre>:backends:<br /> — yaml<br /> — puppet</pre><pre>:yaml:<br /> :datadir:<br /> /vagrant/puppet/hieradata </pre><p>Now you will want to make a directory called hieradata in the puppet directory. From there you can put all of your hiera variables in a file called common.yaml.</p><h3><strong>Multiple Servers</strong></h3><p>One server is great, but if you have a real production infrastructure, it most likely doesn’t consist of a single machine. Vagrant is pretty nice in that it inherently supports it, you just need to do some modifications to your Vagrantfile. If we wanted to have our database server be separate from our web server. Here is our new Vagrantfile:</p><pre># -*- mode: ruby -*-<br /># vi: set ft=ruby :</pre><pre>Vagrant.configure(“2") do |config|<br /> # All Vagrant configuration is done here. The most common configuration<br /> # options are documented and commented below. For a complete reference,<br /> # please see the online documentation at vagrantup.com.</pre><pre> # Every Vagrant virtual environment requires a box to build off of.<br /> config.vm.box = “puppetlabs-precise64"<br /> config.vm.box_url = “http://puppet-vagrant-boxes.puppetlabs.com/ubuntu-server-12042-x64-vbox4210-nocm.box"</pre><pre> config.vm.define :web do |www| # [1]<br /><a href="http://www.vm.hostname/" target="_blank" rel="noreferrer">www.vm.hostname</a> = “dev-www.kloudless.vm"<br /><a href="http://www.vm.network/" target="_blank" rel="noreferrer">www.vm.network</a> :private_network, ip: “192.168.33.10"<br /><a href="http://www.vm.network/" target="_blank" rel="noreferrer">www.vm.network</a> :forwarded_port, guest: 80, host: 8080<br /> end</pre><pre> config.vm.define :db do |db| # [2]<br /> db.vm.hostname = “db.kloudless.vm”<br /> db.vm.network :private_network, ip: “192.168.33.11"<br /> end</pre><pre> # VirtualBox Specific Customization<br /> config.vm.provider :virtualbox do |vb|<br /> # Use VBoxManage to customize the VM. For example to change memory:<br /> vb.customize [“modifyvm”, :id, “—memory”, “512"]<br /> end</pre><pre> # View the documentation for the provider you’re using for more<br /> # information on available options.</pre><pre> # Enable shell provisioning to bootstrap puppet<br /> config.vm.provision :shell, :path =&gt; “bootstrap.sh”</pre><pre> # Enable provisioning with Puppet stand alone.<br /> config.vm.provision :puppet do |puppet|<br /> puppet.manifests_path = “puppet/manifests”<br /> puppet.manifest_file = “site.pp”<br /> puppet.module_path = “puppet/modules”<br /> puppet.options = “—verbose —debug”<br /> end<br />end </pre><p>The primary change are the blocks labelled [1] and [2], those are just adding the host specific configurations for the network settings, so that they can be dealt with separately and talk to each other. Now that there are two boxes vagrant can refer to, for example if you wanted to just bring up the webserver you would do vagrant up web. The name you refer it to is the key that is the argument to config.vm.define.</p><p>In order to have puppet provision both of the servers, we also need to modify the site.pp file so we take into account the fact that we have two nodes. This is pretty straightforward and ends up essentially splitting the single node declaration into two, resulting in:</p><pre>node ‘dev-www.kloudless.vm' {<br /># Configuring apache<br /> include apache<br /> include apache::mod::php</pre><pre> apache::vhost { $::fqdn:<br /> port =&gt; ‘80',<br /> docroot =&gt; ‘/var/www/test’,<br /> require =&gt; File[‘/var/www/test’],<br /> }</pre><pre># Setting up the document root<br /> file { [‘/var/www’, ‘/var/www/test’] :<br /> ensure =&gt; directory,<br /> }</pre><pre> file { ‘/var/www/test/index.php’ :<br /> content =&gt; ‘&gt;?php echo \’&gt;p&lt;Hello world!&gt;/p&lt;\’ ?&lt;’,<br /> }</pre><pre> # “Realize” the firewall rule<br /> Firewall &lt;| |&gt;<br />}</pre><pre>node ‘db.kloudless.vm’ {<br /> class { ‘mysql::server’:<br /> config_hash =&gt; { ‘root_password’ =&gt; ‘herpderpderp’ },<br /> }</pre><pre> include mysql::php</pre><pre> # “Realize” the firewall rule<br /> Firewall &lt;| |&gt;<br />} </pre><p>Essentially all that happened, is that we split the original node definitions into two separate ones. Once you have these manifests in place, running vagrant up brings up both virtual machines in sequence. Once they are up, they can communicate over the private network via the configured ip addresses. The hostnames you configure can’t get resolved (it wouldn’t be too hard to put the ip’s and hostnames in each server’s /etc/hosts file through puppet, but that isn’t too relevant here). Now this is more like something you would see in your actual infrastructure.</p><h3><strong>Moving to the Cloud</strong></h3><p>Once you have a real application developed and configured you probably want it to be accessible to everyone, so why not push it out to Amazon’s EC2! This can be done easily through the AWS provider add on to Vagrant. This will basically be a different Vagrantfile that you will use specifically to push to EC2. In order to replicate the configuration we had locally, you first need to install the plugin:</p><pre>$ vagrant plugin install vagrant-aws </pre><p>Once you have the plugin installed, we are going to take advice from the plugin’s docs to get started quickly using a dummy box. All this means is that our configuration will be explicit within the declaration of the box. To register the dummy box, we do the following:</p><pre>$ vagrant box add dummy <a href="https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box" target="_blank" rel="noreferrer">https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box</a> </pre><p>Then we need to modify our existing Vagrantfile to create and provision the box, since it is going to be pretty different, we can create the different configuration blocks:</p><pre># Begin the AWS Provider Configuration:<br /> config.vm.provider :aws do |aws,override|<br /> aws.access_key_id = “YOUR KEY”<br /> aws.secret_access_key = “YOUR SECRET KEY”<br /> aws.keypair_name = “KEYPAIR NAME”<br /> aws.region = “us-west-2"</pre><pre> aws.ami = “ami-ff68f8cf” # Ubuntu 12.04LTS in us-west-2"</pre><pre> override.ssh.username = “ubuntu”<br /> override.ssh.private_key_path = “PATH TO YOUR PRIVATE KEY”<br /> end</pre><pre> # This box will be brought up in EC2<br /> config.vm.define :web_aws do |web|<br /> web.vm.box = “dummy”<br /> web.vm.hostname = “www.kloudless.aws" # Dummy hostname<br /> end </pre><p>These blocks can just be added into your Vagrantfile before the final end. This assumes that you already have an account and a key-pair set up, so you will need to substitute your credentials into the proper place. I have chosen the Ubuntu 12.04LTS AMI because it is easy to use and us-west-2 because it is pretty close to where I am located (it is in Oregon). Now here is the somewhat tricky bit, because of the way that EC2 works, you won’t really know the hostname of the machine before you bring it up and the network configuration options of Vagrant don’t support setting the hostname. There are a couple ways around this:</p><ol><li><a href="https://github.com/jordansissel/puppet-examples/tree/master/nodeless-puppet/" target="_blank" rel="noreferrer">Nodeless Puppet</a>: A pretty novel approach that is fact driven. It is interesting and probably what I would recommend if you are going to use this in a real production environment.</li><li>Just bring it up and do provisioning afterwards: This is clunky, but easy and what I will do for this blog post.</li></ol><p>So you will bring up your vm with vagrant up web_aws. The shell provisioning will go ahead just fine, but the puppet provisioning will fail. Ths is ok, we just need another puppet node definition. Basically I am going to just copy the node definition on dev-www (if you wanted to bring up the database server in EC2 it would be the same kind of process):</p><pre>node ‘THE NEW HOSTNAME’ {<br /> # Configuring apache<br /> include apache<br /> include apache::mod::php</pre><pre> apache::vhost { $::fqdn:<br /> port =&gt; ‘80',<br /> docroot =&gt; ‘/var/www/test’,<br /> require =&gt; File[‘/var/www/test’],<br /> }</pre><pre> # Setting up the document root<br /> file { [‘/var/www’, ‘/var/www/test’] :<br /> ensure =&gt; directory,<br /> }</pre><pre> file { ‘/var/www/test/index.php’ :<br /> content =&gt; ‘&gt;?php echo \’&gt;p&lt;Hello world!&gt;/p&lt;\’ ?&lt;’,<br /> }</pre><pre> # “Realize” the firewall rule<br /> Firewall &lt;| |&gt;<br />}</pre><p>You can replace THE NEW HOSTNAME with the short domain name that the node thinks it has, in my case it was ip-10-251-32-195. Now you can actually provision your vm with vagrant provision web_aws. In order to actually view the test page, you will need to have your security groups set up properly, but if you just want to check you can vagrant ssh web_aws and then curl <a href="http://localhost/" target="_blank" rel="noreferrer">http://localhost</a> and see that it works.</p><h4><strong>Extra Notes</strong></h4><p>Some things work differently when you are using the AWS provider and the main one you will notice is the shared directories. These get sync’d with rsync every time you run vagrant up, vagrant reload, or vagrant provision. You can also build a bunch more aws configuration into your box definition, so you don’t have to specify it by hand.</p><p>Since it is in EC2 you can take advantage of tags and user data. In our production puppet environment, we have an enc that decides what classes to give an instance based on its tags, but that requires a puppet master, which I didn’t really talk about (right now, vagrant just uses puppet apply).</p><h3><strong>Conclusion</strong></h3><p>Hopefully I have given you a good taste of how easy it is to put these two tools together to make your development and deployment a lot easier! Puppet is a really great tool and I highly recommend learning more so you can take full advantage of this work flow. I am still working to fully utilize all these great tools and it would be great to hear about other peoples’ experiences.</p><br />";